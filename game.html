<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
 <link rel="icon" type="image/png" href="https://uploads.onecompiler.io/43u4wb3ft/43unfu266/Black%20and%20White%20Circle%20Class%20Logo.png">
<title>Student Game Hub </title>
<!--
  Student Game Hub - Enhanced Edition
  - RE-ADDED: Local storage for player name is back for user convenience.
  - REMOVED: All Gemini LLM features.
  - UPGRADED: Leaderboard is now 100% ONLINE with Firebase Firestore (segmented by Game/Difficulty).
  - ADDED: Battleship (Hải Chiến) now supports both AI (Single Player) and PvP.
  - UPGRADED: Tic-Tac-Toe supports MULTIPLE GRID SIZES (3x3, 6x6, 8x8, 10x10).
  - MODIFIED: Quiz now shows 6 shuffled questions.
  - FIX (CRITICAL): PvP auto-matching logic and various game UI rendering issues.
  - FIX (CRITICAL): ReferenceError: currentPlayer is not defined in Battleship AI mode.
  - FIX (CRITICAL): Removed lobby deletion on exit to prevent Firebase permission errors.
-->
<style>
  @keyframes background-pan {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }

  :root{
    --bg:#0b1020;
    --card:#1e293bcc;
    --accent1: #ff6ec7;
    --accent2: #7df9ff;
    --accent3: #ffd36e;
    --muted:#99a0b0;
    --radius: 16px;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    font-size: 16px;
  }
  *{box-sizing:border-box}
  html,body{
    height:100%; 
    margin:0; 
    background-color: var(--bg);
    background-image:
      radial-gradient(1000px 500px at -10% -10%, rgba(255,110,199,0.1), transparent 50%),
      radial-gradient(1200px 600px at 110% 110%, rgba(125,249,255,0.1), transparent 50%);
    background-size: 200% 200%;
    animation: background-pan 25s ease infinite;
    color:#e6eef8;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    scroll-behavior: smooth;
  }
  .app{
    width: 100%;
    max-width:1200px;
    margin:0 auto;
    padding: 24px 16px;
  }
  header{
    display:flex;
    flex-wrap: wrap;
    gap:16px;
    align-items:center;
    margin-bottom:24px;
  }
  .logo{
    width:64px;height:64px;border-radius:16px;
    background: conic-gradient(from 150deg at 50% 50%, var(--accent1), var(--accent2), var(--accent3), var(--accent1));
    display:flex;align-items:center;justify-content:center;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    font-weight:700;color:#051025;font-size:14px;
    flex-shrink: 0;
  }
  h1{margin:0;font-size:22px}
  p.lead{margin:0;color:var(--muted);font-size:14px; max-width: 40ch;}
  .top-right{margin-left:auto;display:flex;gap:10px;align-items:center}
  .card{
    background:var(--card);
    border-radius:var(--radius);
    padding:18px;
    box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    border:1px solid rgba(255,255,255,0.05);
    transition: all 0.3s ease-in-out;
    position: relative;
    overflow: hidden;
  }
  
  .card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(800px circle at var(--mouse-x) var(--mouse-y), rgba(255, 255, 255, 0.06), transparent 40%);
    z-index: 0;
    opacity: 0;
    transition: opacity 0.5s;
    pointer-events: none; /* FIX: Allow clicks to pass through the glow effect */
  }

  .card:hover::before {
      opacity: 1;
  }
  
  .player-input-card {
    display: flex;
    flex-wrap: wrap; /* Cho phép các thành phần xuống dòng trên mobile */
    gap: 12px;
    align-items: center;
  }
  .player-input-card > * {
    position: relative;
    z-index: 1;
  }

  .controls{display:flex;gap:10px;align-items:center}
  /* Tăng padding cho input và select để dễ chạm trên mobile */
  input[type="text"], .select, .range{padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit;min-width:180px; width: 100%;}
  
  button.btn, button.ghost{
    padding:12px 18px; /* Tăng kích thước nút */
    border-radius:12px;border:0;cursor:pointer;font-weight:600;
    transition: all 0.2s ease-in-out;
    position: relative; z-index: 1;
  }
  button.btn{
    background:linear-gradient(90deg,var(--accent1),var(--accent2)); color:#031226;
    box-shadow: 0 0 15px rgba(255, 110, 199, 0.3), 0 0 15px rgba(125, 249, 255, 0.3);
  }
  button.btn:hover, button.ghost:hover {
    transform: translateY(-2px) scale(1.02);
    box-shadow: 0 8px 25px rgba(0,0,0,0.5);
  }
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.1);color:var(--muted)}
  
  .layout{display:grid;grid-template-columns: 1fr; gap:18px; margin-top:18px}
  .games-grid{display:grid;grid-template-columns: repeat(auto-fill,minmax(240px,1fr)); gap:16px}
  .game-card{padding:16px;border-radius:16px;min-height:140px;display:flex;flex-direction:column;justify-content:space-between;}
  .game-card:hover { transform: translateY(-4px); }
  .game-card .title{font-weight:700; font-size: 18px; position: relative; z-index: 1;}
  .game-card .desc{font-size:14px;color:var(--muted); position: relative; z-index: 1;}
  .game-card .actions{display:flex;gap:8px;align-items:center; position: relative; z-index: 1; flex-wrap: wrap;}
  
  /* overlay & modal */
  .overlay{position:fixed;inset:0;background:rgba(11, 16, 32, 0.85);backdrop-filter: blur(8px);-webkit-backdrop-filter: blur(8px);display:none;justify-content:center;align-items:center;padding:16px;z-index:60; opacity: 0; transition: opacity 0.3s ease;}
  .overlay.visible { opacity: 1; }
  .modal{width:100%;max-width:980px;border-radius:20px;padding:20px;background:#1e293b;box-shadow:0 20px 60px rgba(0,0,0,0.7);border: 1px solid rgba(255,255,255,0.08); transform: scale(0.95); transition: transform 0.3s ease;}
  .overlay.visible .modal { transform: scale(1); }
  
  .modal-header{display:flex;align-items:center;gap:12px;margin-bottom:8px}
  .modal-body{display:flex;justify-content:center;gap:12px;flex-wrap:wrap; align-items: center; position: relative; z-index: 1; flex-direction: column;} 
  /* Tối ưu Canvas cho mobile: Chiếm toàn bộ chiều rộng modal body */
  canvas.game-canvas{background:#000;border-radius:10px;display:block; max-width: 100%; height: auto; image-rendering: -webkit-optimize-contrast; width: 100%;}
  
  .select{padding:12px 2.5rem 12px 10px; background-position:right .7rem center; background-size:1.2em 1.2em;}
  .select option { background-color: #0f172a; color: #e6eef8;}
  .footer{display:flex;justify-content:space-between;align-items:center;margin-top:10px;color:var(--muted);font-size:13px}
  
  /* Game Specific Styles (Responsive) */
  /* TTT CSS (Được định nghĩa lại trong JS để hỗ trợ nhiều kích thước grid) */
  .ttt-cell { width: 100%; height: 100%; aspect-ratio: 1 / 1; font-size: 2.5em;} 

  /* FIXED: 2048 Grid CSS */
  .board2048 { 
    display: grid; 
    grid-template-columns: repeat(4, 1fr); 
    gap: 10px; 
    background-color: #334155; 
    padding: 10px; 
    border-radius: 8px; 
    width: 100%; 
    max-width: 300px; 
    height: auto; 
    aspect-ratio: 1/1; /* Đảm bảo hình vuông */
  }
  .tile2048 { 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    border-radius: 4px; 
    background-color: rgba(255,255,255,0.05); 
    font-weight: bold; 
    font-size: 1.5em; 
  }
  
  /* FIXED: Memory Grid CSS */
  .memory-grid { 
    display: grid; 
    grid-template-columns: repeat(4, 1fr); /* 6 cặp = 4 cột; 8 cặp = 4 cột; 10 cặp = 5 cột */
    gap: 10px; 
    max-width: 350px; 
    margin: auto; 
    width: 100%;
  }
  .memory-card {
    aspect-ratio: 1 / 1; 
    background-color: rgba(0,0,0,0.2); 
    border-radius: 8px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    font-size: 2.2em; 
    cursor: pointer; 
    transition: background-color 0.2s; 
    user-select: none; 
    color: transparent; 
  }
  .memory-card.flipped, .memory-card.matched { color: #031226 !important; }
  .memory-card.matched { background: linear-gradient(90deg,var(--accent2),var(--accent1)); }
  .memory-card.flipped { background-color: rgba(255,255,255,0.1); }


  /* Battleship Grid */
  .battleship-grid {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      grid-template-rows: repeat(10, 1fr);
      gap: 1px;
      max-width: 350px;
      margin: 10px auto;
      background: #334155;
      padding: 1px;
      border-radius: 6px;
  }
  .b-cell {
      width: 100%;
      aspect-ratio: 1 / 1;
      background-color: #1e293b;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2em;
      cursor: pointer;
      transition: background-color 0.1s;
      user-select: none;
      color: var(--accent3);
  }
  .b-cell.miss { background-color: #475569; color: #94a3b8; } /* Xám: bắn trượt */
  .b-cell.hit { background-color: #dc2626; color: #fee2e2; font-weight: bold; } /* Đỏ: bắn trúng */
  .b-cell.ship { background-color: #3b82f6; } /* Xanh: thuyền của mình */
  .b-cell:not(.hit):not(.miss):not(.ship):hover { background-color: #334155; }
  .b-cell:disabled { cursor: default; }
  
  /* small screens - Tối ưu bố cục */
  @media (max-width:900px){ 
    .layout{grid-template-columns:1fr; } 
    .top-right{display:none} 
    .modal{width:95%}
    /* Đưa các nút và input của player về dạng cột trên mobile */
    .player-input-card input[type="text"] { width: 100%; min-width: auto; order: 1; }
    .player-input-card .controls { order: 2; width: 100%; justify-content: space-between; gap: 8px;}
    .player-input-card .control-row { order: 4; margin-top: 10px; width: 100%; display: flex; align-items: center; justify-content: space-between;}
    .player-input-card .control-row label { flex-shrink: 0; }
    .player-input-card .control-row select { width: 60%; }
    
    .games-grid { grid-template-columns: repeat(auto-fill,minmax(150px,1fr)); }
  }
  @media (min-width: 901px) {
    .layout{grid-template-columns: 2fr 1fr; } /* Desktop layout */
  }
  
  /* colorful cards - NEW PALETTE */
  .g1 { background: linear-gradient(135deg, rgba(192, 38, 211, 0.2), rgba(255, 110, 199, 0.15)); border-color: rgba(192, 38, 211, 0.3); } /* Quiz - Magenta */
  .g2 { background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(110, 231, 183, 0.15)); border-color: rgba(16, 185, 129, 0.3); } /* Memory - Emerald */
  .g3 { background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(251, 146, 60, 0.15)); border-color: rgba(239, 68, 68, 0.3); } /* Click Speed - Red/Orange */
  .g4 { background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(96, 165, 250, 0.15)); border-color: rgba(59, 130, 246, 0.3); } /* Snake - Blue */
  .g5 { background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(167, 139, 250, 0.15)); border-color: rgba(139, 92, 246, 0.3); } /* TicTacToe - Violet */
  .g6 { background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(251, 191, 36, 0.15)); border-color: rgba(245, 158, 11, 0.3); } /* Flappy - Amber */
  .g7 { background: linear-gradient(135deg, rgba(236, 72, 153, 0.2), rgba(244, 114, 182, 0.15)); border-color: rgba(236, 72, 153, 0.3); } /* 2048 - Pink */
  .g8 { background: linear-gradient(135deg, rgba(0, 190, 190, 0.2), rgba(125, 249, 255, 0.15)); border-color: rgba(125, 249, 255, 0.3); } /* Battleship - Cyan */

  .center{text-align:center}
  /* Style cho Gemini LLM Explanation (Đã loại bỏ nhưng giữ lại .gemini-explanation để tránh lỗi nếu có) */
  .gemini-explanation {
      display: none; /* Ẩn hoàn toàn */
  }
</style>

<!-- Vercel Analytics Scripts -->
  <script src="/_vercel/insights/script.js"></script>
  <script src="/_vercel/speed-insights/script.js"></script>

</head>
<body>
<div class="app">
  <header>
    <div class="logo">GAME</div>
    <div>
      <h1>Student Game Hub </h1>
      <p class="lead">Giao diện mới, hiệu ứng sống động và bảng xếp hạng đồng bộ Đám mây.</p>
    </div>
    <div class="top-right">
      <div class="card" style="padding:8px 10px">
        <div style="font-size:12px;color:var(--muted)">Người chơi:</div>
        <div id="playerNameDisplay" style="font-weight:700">— chưa đăng nhập —</div>
      </div>
    </div>
  </header>

  <div class="layout">
    <div>
      <div class="card player-input-card" style="margin-bottom:12px;">
        <input id="playerNameInput" type="text" placeholder="Nhập tên (bắt buộc)" />
        <div class="controls">
          <button class="btn" id="btnStart">Lưu tên & Bắt đầu</button>
          <button class="ghost" id="btnClear">Xóa tên</button>
        </div>
        <!-- Nút Gợi ý Tên đã được loại bỏ -->
        <div class="control-row">
          <label class="small muted">Theme</label>
          <select id="themeSelect" class="select">
            <option value="rainbow">Nhiều màu</option>
            <option value="neon">Neon</option>
            <option value="dark">Dark</option>
            <option value="light">Light</option>
          </select>
        </div>
      </div>

      <div class="games-grid">
        <div class="game-card g1 card">
          <div>
            <div class="title">Quiz — 6 câu</div>
            <div class="desc">Trả lời nhanh, có timer.</div>
          </div>
          <div class="actions">
            <select class="select" id="quizDifficulty">
              <option value="easy">Dễ</option><option value="normal" selected>Thường</option><option value="hard">Khó</option>
            </select>
            <button class="btn play-btn" data-game="quiz" data-mode="ai">Chơi AI</button>
          </div>
        </div>

        <div class="game-card g2 card">
          <div>
            <div class="title">Memory — Ghép đôi</div>
            <div class="desc">Lật thẻ tìm cặp.</div>
          </div>
          <div class="actions">
            <select class="select" id="memoryDifficulty">
              <option value="easy">Dễ (6 cặp)</option><option value="normal" selected>Thường (8 cặp)</option><option value="hard">Khó (10 cặp)</option>
            </select>
            <button class="btn play-btn" data-game="memory" data-mode="ai">Chơi AI</button>
          </div>
        </div>

        <div class="game-card g3 card">
          <div>
            <div class="title">Click Speed</div>
            <div class="desc">Nhấp thật nhiều trong 10s.</div>
          </div>
          <div class="actions">
            <select class="select" id="clickDuration">
              <option value="5">5s</option><option value="10" selected>10s</option><option value="20">20s</option>
            </select>
            <button class="btn play-btn" data-game="clickspeed" data-mode="ai">Chơi AI</button>
          </div>
        </div>

        <div class="game-card g4 card">
          <div>
            <div class="title">Snake</div>
            <div class="desc">Rắn ăn mồi kinh điển.</div>
          </div>
          <div class="actions">
            <select class="select" id="snakeDifficulty">
              <option value="easy">Chậm</option><option value="normal" selected>Trung bình</option><option value="hard">Nhanh</option>
            </select>
            <button class="btn play-btn" data-game="snake" data-mode="ai">Chơi AI</button>
          </div>
        </div>

        <div class="game-card g6 card">
          <div>
            <div class="title">Flappy (mini)</div>
            <div class="desc">Nhấn để bay, tránh chạm ống.</div>
          </div>
          <div class="actions">
            <select class="select" id="flappyDifficulty">
              <option value="easy">Dễ</option><option value="normal" selected>Thường</option><option value="hard">Khó</option>
            </select>
            <button class="btn play-btn" data-game="flappy" data-mode="ai">Chơi AI</button>
          </div>
        </div>

        <div class="game-card g7 card">
          <div>
            <div class="title">2048 (mini)</div>
            <div class="desc">Gộp số để đạt 2048.</div>
          </div>
          <div class="actions">
            <button class="btn play-btn" data-game="2048" data-mode="ai">Chơi AI</button>
          </div>
        </div>
        
        <div class="game-card g5 card">
          <div>
            <div class="title">Tic-Tac-Toe</div>
            <div class="desc">Cờ caro 3x3 đến 10x10.</div>
          </div>
          <div class="actions">
            <!-- Thêm Select Box chọn kích thước bàn cờ -->
            <select class="select" id="tictactoeSize">
              <option value="3">3x3 (Cổ điển)</option>
              <option value="6">6x6</option>
              <option value="8">8x8</option>
              <option value="10">10x10</option>
            </select>
            <select class="select" id="tictactoeMode">
              <option value="ai">Chơi AI</option>
              <option value="pvp">Chơi PvP</option>
            </select>
            <button class="btn play-btn" data-game="tictactoe" data-mode="dynamic">Chơi</button>
          </div>
        </div>

        <div class="game-card g8 card">
          <div>
            <div class="title">Hải Chiến</div>
            <div class="desc">Sắp xếp đội hình, bắn thuyền đối thủ.</div>
          </div>
          <div class="actions">
            <select class="select" id="battleshipMode">
              <option value="ai">Chơi AI</option>
              <option value="pvp">Chơi PvP</option>
            </select>
            <button class="btn play-btn" data-game="battleship" data-mode="dynamic">Chơi</button>
          </div>
        </div>
      </div>
    </div>

    <aside class="side">
      <div class="card settings">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>Cài đặt chung</strong><div class="muted small">Tùy chỉnh giao diện & âm thanh</div></div>
          <div>
            <label class="small muted">Music</label>
            <select id="musicToggle" class="select">
              <option value="on" selected>Bật</option><option value="off">Tắt</option>
            </select>
          </div>
        </div>

        <div style="margin-top:10px">
          <div class="row" style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
            <label class="small">Theme intensity</label>
            <input type="range" id="themeIntensity" min="0" max="100" value="60" class="range" />
          </div>
          <div class="row" style="display:flex;gap:8px;align-items:center">
            <label class="small">Leaderboards</label>
            <!-- Xóa nút Export và Reset khỏi giao diện -->
            <div style="margin-left:auto"><button class="ghost" style="opacity:0.5; cursor: default;" disabled>Đã kết nối Cloud</button></div>
          </div>
        </div>
      </div>

      <div class="card leaderboard">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <div><strong>Bảng xếp hạng</strong><div id="leaderboardStatus" class="muted small">Đang kết nối...</div></div>
        </div>
        
        <!-- Dropdown chọn Game và Độ khó -->
        <div style="display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
            <select id="leaderboardGameSelect" class="select" style="flex: 1;">
                <option value="all">Tất cả Game</option>
                <option value="quiz">Quiz Nhanh</option>
                <option value="memory">Memory</option>
                <option value="clickspeed">Click Speed</option>
                <option value="snake">Snake</option>
                <option value="flappy">Flappy mini</option>
                <option value="2048">2048</option>
                <option value="tictactoe">Tic-Tac-Toe</option>
                <option value="battleship">Hải Chiến</option>
            </select>
            <select id="leaderboardDifficultySelect" class="select" style="width: 120px;">
                <option value="all">Tất cả ĐK</option>
                <option value="easy">Dễ</option>
                <option value="normal">Thường</option>
                <option value="hard">Khó</option>
                <option value="5">5s</option>
                <option value="10">10s</option>
                <option value="20">20s</option>
                <option value="default">Mặc định</option>
            </select>
        </div>

        <div class="board-wrap" id="leaderboardWrap">
          <table id="leaderboardTable">
            <thead><tr><th>#</th><th>Tên</th><th>Score</th><th>Game/ĐK</th><th>Ngày</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </aside>
  </div>
</div>

<!-- Game & Alert Modals -->
<div id="overlay" class="overlay" style="display:none">
  <div class="modal card">
    <div class="modal-header">
      <div style="font-weight:800" id="modalTitle">Game</div>
      <div class="muted small" id="modalSubtitle">—</div>
      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <!-- Đã loại bỏ Loading spinner cho Gemini -->
        <button class="ghost" id="btnMute">Tắt nhạc</button>
        <button class="ghost" id="btnExit">Thoát</button>
      </div>
    </div>
    <div class="modal-body" id="modalBody"></div>
    <div class="footer">
      <div class="muted small">Điểm sẽ được lưu khi kết thúc trò chơi</div>
      <div>
        <span class="muted small">Người chơi: </span><strong id="modalPlayer"></strong>
      </div>
    </div>
  </div>
</div>
<div id="customAlert" class="overlay" style="z-index: 100; display: none;">
  <div class="modal card" style="max-width: 400px; text-align: center;">
    <div id="customAlertMessage" style="margin-bottom: 20px; font-size: 1.1em; line-height: 1.5;"></div>
    <div style="display: flex; justify-content: center; gap: 10px;">
        <button class="btn" id="customAlertOk">OK</button>
        <button class="ghost" id="customAlertCancel" style="display: none;">Hủy</button>
    </div>
  </div>
</div>

<script type="module">
  // Import the functions you need from the SDKs you need
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.10.0/firebase-app.js";
  import { getFirestore, collection, query, onSnapshot, addDoc, orderBy, limit, where, getDoc, setDoc, doc, updateDoc, deleteDoc, arrayUnion, getDocs } from "https://www.gstatic.com/firebasejs/9.10.0/firebase-firestore.js";
  import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.10.0/firebase-auth.js";
  
  // Cấu hình Firebase mới của bạn
  const firebaseConfig = {
    apiKey: "AIzaSyArKIBD9RWIOhNgPrPLKtPHn1EsQUHjmE8",
    authDomain: "score-57210.firebaseapp.com",
    projectId: "score-57210",
    storageBucket: "score-57210.firebasestorage.app",
    messagingSenderId: "425618398285",
    appId: "1:425618398285:web:47eccf49c844df2e865004"
  };

  let db;
  let auth;
  let firebaseActive = false;

  try {
    const app = initializeApp(firebaseConfig);
    db = getFirestore(app);
    auth = getAuth(app);
    firebaseActive = true;
  } catch (e) {
    console.error("Firebase initialization failed:", e);
    document.getElementById('leaderboardStatus').textContent = 'Cloud bị lỗi.';
  }

  (function() {
    "use strict";
    
    // --- State and Constants ---
    let APP = {
      playerName: null,
      leaderboard: [],
      currentGame: null,
      settings: { music: true, theme: 'rainbow' }
    };

    // --- DOM References ---
    const getEl = id => document.getElementById(id);
    const playerInput = getEl('playerNameInput'), btnStart = getEl('btnStart'), btnClear = getEl('btnClear');
    const playerDisplay = getEl('playerNameDisplay'), overlay = getEl('overlay'), modalBody = getEl('modalBody');
    const modalTitle = getEl('modalTitle'), modalSubtitle = getEl('modalSubtitle'), modalPlayer = getEl('modalPlayer');
    const btnExit = getEl('btnExit'), btnMute = getEl('btnMute'), lbTableBody = document.querySelector('#leaderboardTable tbody');
    const themeSelect = getEl('themeSelect');
    const musicToggle = getEl('musicToggle');
    const customAlert = getEl('customAlert'), customAlertMessage = getEl('customAlertMessage');
    let customAlertOk = getEl('customAlertOk'), customAlertCancel = getEl('customAlertCancel');
    const leaderboardStatus = getEl('leaderboardStatus');
    
    // Thêm các tham chiếu cho bộ lọc Bảng xếp hạng
    const lbGameSelect = getEl('leaderboardGameSelect');
    const lbDifficultySelect = getEl('leaderboardDifficultySelect');


    // --- Core Functions ---
    const Utils = {
      nowISO: () => new Date().toISOString(),
      shuffleArray: a => { const arr = a.slice(); for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; },
      
      // Hàm tạo ID phòng chơi ngẫu nhiên
      generateGameId: () => Math.random().toString(36).substring(2, 8).toUpperCase(),
      
      // Hàm Battleship: Tự động sắp xếp thuyền ngẫu nhiên
      placeShipsRandomly: () => {
        const ships = [5, 4, 3, 3, 2]; // Kích thước các thuyền
        let board = Array(10).fill(0).map(() => Array(10).fill(false)); // true là có thuyền
        
        for (const size of ships) {
          let placed = false;
          while (!placed) {
            const isHorizontal = Math.random() < 0.5;
            const row = Math.floor(Math.random() * 10);
            const col = Math.floor(Math.random() * 10);

            // Kiểm tra vị trí
            let canPlace = true;
            for (let i = 0; i < size; i++) {
              const r = isHorizontal ? row : row + i;
              const c = isHorizontal ? col + i : col;
              
              if (r < 0 || r >= 10 || c < 0 || c >= 10 || board[r][c]) {
                canPlace = false;
                break;
              }
              // Kiểm tra khu vực xung quanh (1 ô đệm)
              for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                  const nr = r + dr;
                  const nc = c + dc;
                  // Kiểm tra xem ô đó CÓ THUYỀN hay không
                  if (nr >= 0 && nr < 10 && nc >= 0 && nc < 10 && board[nr][nc]) {
                    canPlace = false;
                    break;
                  }
                }
                if (!canPlace) break;
              }
              if (!canPlace) break;
            }

            if (canPlace) {
              for (let i = 0; i < size; i++) {
                const r = isHorizontal ? row : row + i;
                const c = isHorizontal ? col + i : col;
                board[r][c] = true;
              }
              placed = true;
            }
          }
        }
        return board;
      },
      
      // Hàm Battleship: Chuyển đổi từ mảng 2D sang mảng 1D cho Firestore
      boardToFlat: (board) => board.flat(),
      
      // Hàm Battleship: Đếm số lượng ô thuyền còn lại
      countShipsLeft: (shipBoard, hitBoard) => {
          let hits = 0;
          const gridSize = 10;
          for(let r=0; r<gridSize; r++) {
              for(let c=0; c<gridSize; c++) {
                  // shipBoard là mảng 2D Boolean, hitBoard là mảng 2D string
                  if(shipBoard[r][c] && hitBoard[r][c] === 'hit') {
                      hits++;
                  }
              }
          }
          return 17 - hits; // 17 là tổng số ô của các thuyền [5, 4, 3, 3, 2]
      }
    };


    // --- UI/Modal Management ---
    function showAlert(message, callback) {
        customAlertMessage.innerHTML = message;
        customAlertOk.style.display = 'inline-block';
        customAlertCancel.style.display = 'none';
        customAlert.style.display = 'flex';
        setTimeout(() => customAlert.classList.add('visible'), 10);
        
        const newOkButton = customAlertOk.cloneNode(true);
        customAlertOk.parentNode.replaceChild(newOkButton, customAlertOk);
        customAlertOk = newOkButton; 

        customAlertOk.onclick = () => {
            customAlert.classList.remove('visible');
            setTimeout(() => { customAlert.style.display = 'none'; if (callback) callback(); }, 300);
        };
    }

    function showConfirm(message, onConfirm) {
        customAlertMessage.textContent = message;
        customAlertOk.textContent = 'Xác nhận';
        customAlertCancel.textContent = 'Hủy';
        customAlertOk.style.display = 'inline-block';
        customAlertCancel.style.display = 'inline-block';
        customAlert.style.display = 'flex';
        setTimeout(() => customAlert.classList.add('visible'), 10);

        const newOkButton = customAlertOk.cloneNode(true);
        customAlertOk.parentNode.replaceChild(newOkButton, customAlertOk);
        customAlertOk = newOkButton;
        const newCancelButton = customAlertCancel.cloneNode(true);
        customAlertCancel.parentNode.replaceChild(newCancelButton, customAlertCancel);
        customAlertCancel = newCancelButton;

        const close = (result) => {
            customAlert.classList.remove('visible');
            setTimeout(() => { customAlert.style.display = 'none'; if (onConfirm) onConfirm(result); }, 300);
        };
        customAlertOk.onclick = () => close(true);
        customAlertCancel.onclick = () => close(false);
    }
    
    // Lắng nghe thay đổi bộ lọc
    function setupLeaderboardListeners() {
        lbGameSelect.addEventListener('change', refreshLeaderboardUI);
        lbDifficultySelect.addEventListener('change', refreshLeaderboardUI);
    }

    function refreshLeaderboardUI() {
        if (!firebaseActive) {
            leaderboardStatus.textContent = 'Lỗi kết nối Firebase.';
            return;
        }
        
        const selectedGame = lbGameSelect.value;
        const selectedDifficulty = lbDifficultySelect.value;
        
        leaderboardStatus.textContent = 'Online (Đồng bộ)';
        
        let conditions = [];
        if (selectedGame !== 'all') {
            conditions.push(where("gameId", "==", selectedGame));
        }
        // Thêm điều kiện lọc độ khó chỉ khi nó khác 'all'
        if (selectedDifficulty !== 'all') {
            conditions.push(where("difficulty", "==", selectedDifficulty));
        }

        // Tạo Query với các điều kiện lọc
        let q;
        if (conditions.length === 0) {
             // Truy vấn mặc định (Không lọc), sử dụng orderBy của Firebase
            q = query(collection(db, "leaderboard"), orderBy("score", "desc"), limit(50));
        } else {
             // Nếu có lọc, KHÔNG sử dụng orderBy trong Firebase để tránh lỗi index, chỉ dùng where và limit
             // Sau đó sắp xếp bằng JavaScript
            q = query(collection(db, "leaderboard"), ...conditions, limit(50));
        }
        
        // Sử dụng onSnapshot để lắng nghe cập nhật thời gian thực
        onSnapshot(q, (querySnapshot) => {
            const scores = [];
            const currentUserId = auth.currentUser ? auth.currentUser.uid : null;
            
            querySnapshot.forEach((doc) => {
                scores.push(doc.data());
            });
            
            // Sắp xếp dữ liệu bằng JavaScript sau khi tải về
            if (conditions.length > 0 || selectedGame === 'all') {
                scores.sort((a, b) => b.score - a.score);
            }
            
            renderLeaderboard(scores, currentUserId);
        }, (error) => {
            console.error("Firebase snapshot error (Check Security Rules and composite indexes):", error);
            leaderboardStatus.textContent = 'Lỗi đọc dữ liệu Cloud. (Kiểm tra Rules/Indexes)';
        });
    }

    function renderLeaderboard(scores, currentUserId) {
        lbTableBody.innerHTML = '';
        // Giới hạn hiển thị 50 kết quả đầu tiên (dù đã được limit trong truy vấn hoặc sắp xếp)
        scores.slice(0, 50).forEach((e, i) => {
            const nameDisplay = escapeHtml(e.name);
            const gameDiff = gameTitle(e.gameId) + (e.difficulty && e.difficulty !== 'default' ? ` (${e.difficulty.toUpperCase()})` : '');
            
            const tr = document.createElement('tr');
            if (e.userId === currentUserId) {
                tr.style.backgroundColor = 'rgba(255, 211, 110, 0.1)'; 
            }
            
            tr.innerHTML = `<td>${i+1}</td><td>${nameDisplay}</td><td>${e.score}</td><td>${gameDiff}</td><td>${new Date(e.date).toLocaleDateString()}</td>`;
            lbTableBody.appendChild(tr);
        });
    }

    function escapeHtml(s){ return (s+'').replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
    
    function applyTheme(){
      const t = APP.settings.theme;
      const themes = {
        rainbow: ['#ff6ec7', '#7df9ff', '#ffd36e'],
        neon: ['#7df9ff', '#a1ffba', '#ff7bd6'],
        dark: ['#556bff', '#9b8cff', '#00d4ff'],
        light: ['#ffa726', '#ffcc80', '#90caf9']
      };
      const [c1, c2, c3] = themes[t] || themes.rainbow;
      document.documentElement.style.setProperty('--accent1', c1);
      document.documentElement.style.setProperty('--accent2', c2);
      document.documentElement.style.setProperty('--accent3', c3);
    }

    // Hàm lấy độ khó/mode hiện tại (dùng cho việc lưu điểm)
    function getCurrentDifficulty(gameId) {
        const diffMap = {
            quiz: getEl('quizDifficulty').value,
            memory: getEl('memoryDifficulty').value,
            clickspeed: getEl('clickDuration').value,
            snake: getEl('snakeDifficulty').value,
            flappy: getEl('flappyDifficulty').value,
            tictactoe: getEl('tictactoeSize').value, // LƯU KÍCH THƯỚC BÀN CỜ LÀM DIFFICULTY
            battleship: getEl('battleshipMode').value, // LƯU MODE LÀM DIFFICULTY
            '2048': 'default', 
        };
        return diffMap[gameId] || 'default';
    }

    function openGame(gameId, mode){
      if(!APP.playerName){ showAlert('Vui lòng nhập tên trước khi chơi.'); playerInput.focus(); return; }
      
      APP.currentGame = gameId;
      APP.gameMode = mode; // Lưu mode hiện tại

      modalTitle.textContent = gameTitle(gameId);
      modalSubtitle.textContent = gameSubtitle(gameId) + (mode === 'pvp' ? ' (PvP - Cloud)' : ' (AI/Single Player)');
      modalPlayer.textContent = APP.playerName;
      overlay.style.display = 'flex';
      setTimeout(() => overlay.classList.add('visible'), 10);
      modalBody.innerHTML = ''; // clear
      
      const initializers = {
          quiz: initQuiz, memory: initMemory, clickspeed: initClickSpeed, 
          snake: initSnake, flappy: initFlappy, '2048': init2048,
          tictactoe: initTicTacToe, battleship: initBattleship
      };
      if(initializers[gameId]) initializers[gameId](modalBody, mode);
    }

    function closeGame(){
      if(window.GAME && typeof window.GAME.destroy === 'function') try{ window.GAME.destroy(); }catch(e){}
      window.GAME = null;
      overlay.classList.remove('visible');
      setTimeout(() => { overlay.style.display = 'none'; modalBody.innerHTML = ''; }, 300);
      APP.currentGame = null;
    }

    function gameTitle(id){
      return ({quiz:'Quiz Nhanh', memory:'Memory - Ghép đôi', clickspeed:'Click Speed', snake:'Snake', flappy:'Flappy mini', '2048':'2048', tictactoe: 'Tic-Tac-Toe', battleship: 'Hải Chiến'}[id]||id);
    }
    function gameSubtitle(id){
      return ({quiz:'Trả lời nhanh — có timer', memory:'Tìm cặp — ít lượt = nhiều điểm', clickspeed:'Nhấp nhiều nhất trong thời gian', snake:'Rắn săn mồi', flappy:'Nhấn để bay', '2048':'Gộp số để đạt 2048', tictactoe: 'Cờ caro Multi-Grid', battleship: 'Sắp xếp và tấn công'}[id]||'');
    }

    async function pushScore(name, score, gameId){
      if (score <= 0) return;
      
      if(!firebaseActive || !auth.currentUser) {
          console.error("Không thể lưu điểm: Firebase không hoạt động hoặc người dùng chưa đăng nhập.");
          showAlert('Không thể lưu điểm: Vui lòng kiểm tra kết nối Cloud.', null);
          return;
      }
      
      const entry = { 
          name: name, 
          score: Math.round(score), 
          gameId: gameId, 
          difficulty: getCurrentDifficulty(gameId), // LƯU ĐỘ KHÓ/MODE
          date: Utils.nowISO(),
          userId: auth.currentUser.uid // Lưu userId để xác định người chơi
      };
      
      try {
        await addDoc(collection(db, "leaderboard"), entry);
      } catch (e) {
        console.error("Lỗi khi thêm điểm vào Cloud (Check Security Rules): ", e);
        showAlert('Lỗi khi lưu điểm lên Cloud. (Kiểm tra Rules)', null);
      }
    }
    
    // --- Event Listeners Setup ---
    function setupEventListeners() {
        btnStart.addEventListener('click', ()=>{
          const v = (playerInput.value||'').trim();
          if(!v){ showAlert('Vui lòng nhập tên trước khi chơi.'); playerInput.focus(); return; }
          APP.playerName = v;
          playerDisplay.textContent = v;
          modalPlayer.textContent = v;
          // KHÔI PHỤC: Lưu tên người chơi cục bộ
          localStorage.setItem('sg_hub_player_name', v);
          showAlert('Tên đã lưu: ' + v);
        });
        btnClear.addEventListener('click', ()=>{ 
          playerInput.value = ''; 
          // KHÔI PHỤC: Xóa tên người chơi cục bộ
          localStorage.removeItem('sg_hub_player_name');
          APP.playerName = null; 
          playerDisplay.textContent = '— chưa đăng nhập —'; 
        });

        themeSelect.addEventListener('change', (e)=>{ APP.settings.theme = e.target.value; applyTheme(); });
        musicToggle.addEventListener('change', (e)=>{ APP.settings.music = e.target.value !== 'off'; });
        btnMute.addEventListener('click', ()=>{ APP.settings.music = !APP.settings.music; btnMute.textContent = APP.settings.music ? 'Tắt nhạc' : 'Bật nhạc'; });

        btnExit.addEventListener('click', closeGame);
        window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeGame(); });

        document.querySelectorAll('.play-btn').forEach(button => {
          button.addEventListener('click', (e) => {
              const gameId = e.currentTarget.dataset.game;
              let mode = e.currentTarget.dataset.mode;
              
              if (mode === 'dynamic') {
                  // Lấy mode từ select box nếu là dynamic (như tictactoe, battleship)
                  const modeEl = getEl(gameId + 'Mode');
                  if (modeEl) {
                      mode = modeEl.value;
                  }
              }
              if(gameId) openGame(gameId, mode);
          });
        });
        
        document.querySelectorAll('.card').forEach(card => {
          card.onmousemove = e => {
              const rect = card.getBoundingClientRect();
              card.style.setProperty('--mouse-x', `${e.clientX - rect.left}px`);
              card.style.setProperty('--mouse-y', `${e.clientY - rect.top}px`);
          };
        });
        
        setupLeaderboardListeners();
    }
    
    // --- 1) Quiz Implementation ---
    function initQuiz(container, mode){
        const difficulty = getEl('quizDifficulty').value;
        // Chỉ lấy 6 câu hỏi, luôn xáo trộn
        const NUM_QUESTIONS = 6; 
        const timePerQuestion = difficulty==='easy'?18: (difficulty==='normal'?12:8);
        
        // --- 50 Câu hỏi Quiz ---
        const allQuestions = [
            {q:'Thủ đô của Việt Nam là?', a:'Hà Nội', opts:['Hà Nội','Hồ Chí Minh','Đà Nẵng','Hải Phòng']},
            {q:'2 + 3 = ?', a:'5', opts:['4','5','6','3']},
            {q:'Mặt trời mọc ở hướng nào?', a:'Đông', opts:['Tây','Đông','Nam','Bắc']},
            {q:'Việt Nam thuộc châu lục nào?', a:'Á', opts:['Âu','Mỹ','Phi','Á']},
            {q:'Hình vuông có bao nhiêu cạnh?', a:'4', opts:['3','4','5','6']},
            {q:'Tháng nào có 28 ngày?', a:'Tháng Hai', opts:['Tháng Giêng','Tháng Hai','Tháng Ba','Tháng Tư']},
            {q:'Ai là người tìm ra thuyết tương đối?', a:'Albert Einstein', opts:['Isaac Newton','Galileo Galilei','Albert Einstein','Stephen Hawking']}, 
            {q:'Con gì sống dưới nước và có vảy?', a:'Cá', opts:['Gà','Mèo','Cá','Chó']}, 
            {q:'Nguyên tố hóa học nào có ký hiệu là O?', a:'Oxy', opts:['Oxy','Nitơ','Cacbon','Hiđro']}, 
            {q:'Năm 2025 thuộc thế kỷ nào?', a:'XXI', opts:['XIX','XX','XXI','XXII']},
            {q:'Ai là tác giả của Truyện Kiều?', a:'Nguyễn Du', opts:['Hồ Xuân Hương','Nguyễn Trãi','Nguyễn Du','Cao Bá Quát']},
            {q:'Thực vật hô hấp bằng gì?', a:'Lá', opts:['Rễ','Thân','Lá','Hoa']},
            {q:'Núi cao nhất Việt Nam?', a:'Fansipan', opts:['Bạch Mã','Fansipan','Chư Đăng Ya','Langbiang']},
            {q:'Cây thuộc họ lúa?', a:'Mía', opts:['Bắp cải','Mía','Cà chua','Cà phê']},
            {q:'Lục địa lớn nhất thế giới?', a:'Châu Á', opts:['Châu Phi','Châu Âu','Châu Mỹ','Châu Á']},
            {q:'Quốc khánh Việt Nam là ngày nào?', a:'2/9', opts:['30/4','1/5','2/9','19/8']},
            {q:'Đơn vị đo cường độ dòng điện?', a:'Ampere', opts:['Volt','Ohm','Watt','Ampere']},
            {q:'1km bằng bao nhiêu mét?', a:'1000', opts:['10','100','1000','10000']},
            {q:'Tỉnh có diện tích lớn nhất Việt Nam?', a:'Nghệ An', opts:['Đắk Lắk','Thanh Hóa','Nghệ An','Sơn La']},
            {q:'Thành phần chính của không khí?', a:'Nitơ', opts:['Oxy','Cacbon','Nitơ','Hiđro']},
            {q:'Tác giả ' + 'Bình Ngô Đại Cáo' + '?', a:'Nguyễn Trãi', opts:['Nguyễn Du','Hồ Chí Minh','Nguyễn Trãi','Lê Lợi']},
            {q:'Hành tinh nào gần Mặt Trời nhất?', a:'Sao Thủy', opts:['Sao Hỏa','Sao Kim','Sao Thủy','Sao Mộc']},
            {q:'Nước nào có hình chiếc ủng?', a:'Ý', opts:['Pháp','Ý','Đức','Tây Ban Nha']},
            {q:'Con vật có thể xoay đầu 270 độ?', a:'Cú', opts:['Hươu cao cổ','Đại bàng','Cú','Gấu']},
            {q:'Màu cơ bản trong hội họa?', a:'Đỏ, Vàng, Xanh dương', opts:['Đỏ, Xanh lá, Xanh dương','Đỏ, Vàng, Xanh dương','Đen, Trắng, Xám','Hồng, Cam, Tím']},
            {q:'Kim loại nhẹ nhất?', a:'Lithium', opts:['Sắt','Vàng','Lithium','Nhôm']},
            {q:'Quốc hoa của Việt Nam?', a:'Hoa Sen', opts:['Hoa Mai','Hoa Đào','Hoa Sen','Hoa Hồng']},
            {q:'Thể tích hình hộp chữ nhật được tính bằng?', a:'dài x rộng x cao', opts:['dài + rộng + cao','dài x rộng x cao','2 x (dài + rộng)','dài x rộng']},
            {q:'Trong bóng đá, 1 trận có bao nhiêu hiệp?', a:'2', opts:['1','2','3','4']},
            {q:'Ai là Chủ tịch Hồ Chí Minh?', a:'Hồ Chí Minh', opts:['Hồ Chí Minh','Võ Nguyên Giáp','Phạm Văn Đồng','Trần Đại Quang']},
            {q:'Cơ quan lớn nhất trong cơ thể người?', a:'Da', opts:['Gan','Phổi','Tim','Da']},
            {q:'Sông dài nhất Việt Nam?', a:'Sông Đồng Nai', opts:['Sông Hồng','Sông Đồng Nai','Sông Mê Kông','Sông Đà']},
            {q:'Hình tam giác có tổng góc bằng bao nhiêu độ?', a:'180', opts:['90','180','270','360']},
            {q:'1 đô la Mỹ bằng bao nhiêu cent?', a:'100', opts:['10','50','100','1000']},
            {q:'Chất lỏng dẫn điện tốt nhất?', a:'Nước muối', opts:['Nước tinh khiết','Dầu ăn','Nước muối','Cồn']},
            {q:'Tác giả bài hát Tiến Quân Ca?', a:'Văn Cao', opts:['Văn Cao','Phạm Tuyên','Trần Hoàn','Hoàng Vân']},
            {q:'Khí quyển Trái Đất có mấy tầng chính?', a:'5', opts:['3','4','5','6']},
            {q:'Loài cá bay được?', a:'Cá chuồn', opts:['Cá mập','Cá chuồn','Cá voi','Cá hồi']},
            {q:'Đơn vị tiền tệ của Nhật Bản?', a:'Yên', opts:['Won','Nhân dân tệ','Yên','Đô la']},
            {q:'Vật liệu cứng nhất trên Trái Đất?', a:'Kim cương', opts:['Kim cương','Thép','Gỗ','Thủy tinh']},
            {q:'Bác Hồ ra đi tìm đường cứu nước năm nào?', a:'1911', opts:['1930','1945','1911','1954']},
            {q:'Bán kính Trái Đất xấp xỉ bao nhiêu km?', a:'6371', opts:['1200','3500','6371','10000']},
            {q:'Ngôn ngữ lập trình phổ biến nhất?', a:'JavaScript', opts:['Java','C++','Python','JavaScript']},
            {q:'Công thức hóa học của nước?', a:'H₂O', opts:['CO₂','H₂O','O₂','NaCl']},
            {q:'Loại năng lượng không thể tái tạo?', a:'Than đá', opts:['Mặt trời','Gió','Nước','Than đá']},
            {q:'Ai là người đầu tiên đặt chân lên Mặt Trăng?', a:'Neil Armstrong', opts:['Buzz Aldrin','Yuri Gagarin','Neil Armstrong','Alan Shepard']},
            {q:'Môn học nghiên cứu về sự sống?', a:'Sinh học', opts:['Vật lý','Hóa học','Toán học','Sinh học']},
            {q:'Tên gọi khác của bệnh sốt rét?', a:'Sốt rét', opts:['Sốt xuất huyết','Sốt rét','Cảm cúm','Sởi']},
            {q:'Tổ chức Liên Hợp Quốc được thành lập năm nào?', a:'1945', opts:['1918','1945','1954','1989']},
            {q:'Món ăn truyền thống nổi tiếng nhất Việt Nam?', a:'Phở', opts:['Bún chả','Phở','Bánh mì','Gỏi cuốn']},
            {q:'Đơn vị đo tần số?', a:'Hertz', opts:['Volt','Ohm','Hertz','Joule']},
        ];
        // --- End 50 Câu hỏi Quiz ---

        // Xáo trộn và chỉ lấy 6 câu
        const qs = Utils.shuffleArray(allQuestions).slice(0, NUM_QUESTIONS);

        let idx=0, score=0, timeLeft=timePerQuestion;
        
        const root = document.createElement('div');
        root.style.width = '100%';
        // Bố cục Quiz được điều chỉnh để hiển thị tốt trên mobile
        root.innerHTML = `<div id="qWrap" style="margin-top:8px;"></div><div style="margin-top:8px;display:flex;justify-content:space-between;align-items:center; flex-wrap: wrap; gap: 8px;"><div class="muted">Time left: <span id="qTime">${timeLeft}</span>s</div><div>Score: <span id="qScore">${score}</span></div></div>`;
        container.appendChild(root);

        function renderQuestion(){
          const qWrap = root.querySelector('#qWrap'); qWrap.innerHTML = '';
          if(idx>=qs.length){ finishQuiz(); return; }
          const item = qs[idx];
          const qDiv = document.createElement('div');
          qDiv.innerHTML = `<div style="font-weight:700;margin-bottom:10px; font-size: 1.1em;">Q${idx+1} (${idx+1}/${NUM_QUESTIONS}). ${item.q}</div><div style="display:flex; flex-wrap: wrap; gap: 8px;"></div>`;
          const optionsDiv = qDiv.querySelector('div:last-child');
          
          item.opts.forEach(opt=>{
            const b=document.createElement('button'); 
            b.className='btn'; 
            b.style.padding='12px 16px'; // Tăng kích thước nút cho touch
            b.style.flexGrow = 1;
            b.textContent=opt; 
            b.onclick=()=>{ 
              if(opt===item.a) score += 150 + timeLeft*5; 
              idx++; 
              timeLeft = timePerQuestion; 
              root.querySelector('#qScore').textContent = score; 
              renderQuestion(); 
            };
            optionsDiv.appendChild(b);
          });
          qWrap.appendChild(qDiv);
        }

        renderQuestion();
        let timer = setInterval(()=>{ 
            timeLeft--; 
            const el=root.querySelector('#qTime'); 
            if(el) el.textContent=timeLeft; 
            if(timeLeft<=0){ 
                idx++; 
                timeLeft=timePerQuestion; 
                if(idx>=qs.length) finishQuiz(); 
                else renderQuestion(); 
            } 
        }, 1000);
        
        window.GAME = { destroy(){ clearInterval(timer); } };
        
        async function finishQuiz(){
          clearInterval(timer);
          
          const resultContent = `
              <div style="text-align:center; width: 100%;">
                  <h3 style="color: var(--accent1);">Quiz kết thúc!</h3>
                  <p style="font-size: 1.5em; font-weight: bold;">Điểm của bạn: ${score}</p>
                  <!-- Loại bỏ nút giải thích AI -->
              </div>
          `;
          
          // Thay thế body modal bằng kết quả
          modalBody.innerHTML = resultContent;
          
          // Đảm bảo nút Thoát vẫn hoạt động sau khi hiển thị kết quả
          pushScore(APP.playerName, score, 'quiz');
        }
    }

    // --- 2) Memory Implementation (FIXED: Added game logic back) ---
    function initMemory(container, mode){
        const difficulty = getEl('memoryDifficulty').value;
        const pairs = difficulty==='easy'?6: (difficulty==='normal'?8:10);
        // Implement PvP here if needed, current is AI/single player logic
        const fruits = ['🍎', '🍌', '🍇', '🍓', '🍒', '🍑', '🍍', '🥝', '🍉', '🥭', '🥥', '🥑'].slice(0, pairs);
        const cards = Utils.shuffleArray([...fruits, ...fruits]);
        let flipped = [], matched = new Set(), moves=0, lockBoard = false;
        const grid = document.createElement('div'); 
        grid.className = 'memory-grid';
        
        // FIXED: Đảm bảo grid column đúng cho 6, 8, 10 cặp
        let columns = 4;
        if (pairs === 10) columns = 5;
        grid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;

        container.appendChild(grid);
        
        cards.forEach((s,i)=>{
          const c=document.createElement('div'); 
          c.className = 'memory-card';
          c.textContent=s; 
          c.dataset.index=i; 
          c.onclick=()=>flip(i);
          grid.appendChild(c);
        });
        
        const info = document.createElement('div'); info.className='muted small'; info.style.width='100%'; info.style.textAlign='center'; info.style.marginTop='10px'; info.textContent='Moves: 0'; container.appendChild(info);
        
        function flip(i){
          if(lockBoard || flipped.includes(i) || matched.has(i)) return;
          const cardEl = grid.children[i];
          flipped.push(i);
          cardEl.classList.add('flipped');
          // cardEl.style.color = '#031226'; // Đã dùng CSS class

          if(flipped.length===2){
            moves++; info.textContent='Moves: '+moves; lockBoard = true;
            const [idx1, idx2] = flipped;
            if(cards[idx1]===cards[idx2]){ 
              matched.add(idx1); matched.add(idx2); 
              grid.children[idx1].classList.add('matched');
              grid.children[idx2].classList.add('matched');
              grid.children[idx1].classList.remove('flipped');
              grid.children[idx2].classList.remove('flipped');
              flipped=[]; lockBoard=false; 
              if(matched.size===cards.length) finishMem(); 
            } else { 
              setTimeout(()=>{ 
                grid.children[idx1].classList.remove('flipped');
                grid.children[idx2].classList.remove('flipped');
                // grid.children[idx1].style.color = 'transparent'; // Đã dùng CSS class
                // grid.children[idx2].style.color = 'transparent'; // Đã dùng CSS class
                flipped=[]; lockBoard=false;
              }, 800); 
            }
          }
        }
        
        function finishMem(){ 
          const score = Math.max(0, 5000 - moves*50); 
          showAlert('Hoàn thành! Điểm: '+score, () => {pushScore(APP.playerName, score, 'memory'); closeGame();}); 
        }
        window.GAME = { destroy(){} };
    }

    // --- 3) Click Speed Implementation ---
    function initClickSpeed(container, mode){
        const duration = parseInt(getEl('clickDuration').value,10) || 10;
        // Implement PvP here if needed, current is AI/single player logic
        let running=false, timeLeft=duration, count=0, timer=null;
        const root=document.createElement('div'); root.innerHTML = `<div style="display:flex;gap:12px;align-items:center; flex-wrap: wrap;"><div><strong>Time:</strong> <span id="csTime">${timeLeft}</span>s</div><div><strong>Clicks:</strong> <span id="csCount">${count}</span></div></div><div style="margin-top:10px; display:flex; gap: 10px;"><button class="btn" id="csStart">Bắt đầu</button> <button class="ghost" id="csReset">Reset</button></div><div style="margin-top:14px"><button class="btn" id="csTap" style="font-size:20px;padding:28px 40px; width: 100%;">NHẤP!</button></div>`;
        container.appendChild(root);
        const elTime = root.querySelector('#csTime'), elCount = root.querySelector('#csCount');
        root.querySelector('#csStart').onclick = ()=>{
          if(running) return;
          running=true; count=0; timeLeft=duration; elTime.textContent=timeLeft; elCount.textContent=count;
          timer = setInterval(()=>{ timeLeft--; elTime.textContent=timeLeft; if(timeLeft<=0){ clearInterval(timer); running=false; const score = count; showAlert('Hết giờ! Clicks: '+count, () => {pushScore(APP.playerName, score, 'clickspeed'); closeGame();}); } },1000);
        };
        root.querySelector('#csTap').onclick = ()=>{ if(!running) return; count++; elCount.textContent=count; };
        root.querySelector('#csReset').onclick = ()=>{ clearInterval(timer); running=false; timeLeft=duration; count=0; elTime.textContent=timeLeft; elCount.textContent=count; };
        window.GAME = { destroy(){ if(timer) clearInterval(timer); } };
    }
    
    // --- 4) Snake Implementation ---
    function initSnake(container, mode){
      const difficulty = getEl('snakeDifficulty').value;
      const speed = difficulty==='easy'?160: (difficulty==='normal'?110:70);
      const cw = 20, cols = 20, rows = 15;
      
      let canvas = document.createElement('canvas'); 
      canvas.width = cols*cw; canvas.height = rows*cw; 
      canvas.className='game-canvas'; 
      canvas.style.width = '100%'; canvas.style.maxWidth = `${cols * cw}px`;
      container.appendChild(canvas);
      
      let ctx = canvas.getContext('2d');
      let snake = [{x:3,y:7},{x:2,y:7},{x:1,y:7}], dir='right', food=randomFood(), score=0;
      let tick=null; draw();
      
      function randomFood(){ let p; do{ p={x:Math.floor(Math.random()*cols), y:Math.floor(Math.random()*rows)} } while(snake.some(s=>s.x===p.x && s.y===p.y)); return p; }
      function draw(){ ctx.fillStyle='#061022'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#ff4d6d'; ctx.fillRect(food.x*cw+2, food.y*cw+2, cw-4, cw-4); snake.forEach((s,i)=>{ ctx.fillStyle = i===0 ? '#ffd36e' : '#7df9ff'; ctx.fillRect(s.x*cw+1, s.y*cw+1, cw-2, cw-2); }); ctx.fillStyle='#fff'; ctx.font='14px Inter'; ctx.fillText('Score: '+score, 8, 16); }
      function step(){
        const head = {...snake[0]};
        if(dir==='right') head.x++; if(dir==='left') head.x--; if(dir==='up') head.y--; if(dir==='down') head.y++;
        if(head.x<0||head.y<0||head.x>=cols||head.y>=rows||snake.some(s=>s.x===head.x && s.y===head.y)){
          clearInterval(tick); showAlert('Game Over! Score: '+score, () => {pushScore(APP.playerName, score, 'snake'); closeGame();}); return;
        }
        snake.unshift(head);
        if(head.x===food.x && head.y===food.y){ score+=10; food=randomFood(); }
        else snake.pop();
        draw();
      }
      const onKey = (e) => {
          if(e.key==='ArrowUp' && dir!=='down') dir='up';
          if(e.key==='ArrowDown' && dir!=='up') dir='down';
          if(e.key==='ArrowLeft' && dir!=='right') dir='left';
          if(e.key==='ArrowRight' && dir!=='left') dir='right';
      };
      document.addEventListener('keydown', onKey);
      tick = setInterval(step, speed);
      window.GAME = { destroy(){ clearInterval(tick); document.removeEventListener('keydown', onKey); } };
    }

    /* 5) Flappy mini Implementation - FIXED: Logic to prevent immediate game over */
    function initFlappy(container, mode){
      const diff = getEl('flappyDifficulty').value;
      const gravity = diff==='easy'?0.45: (diff==='normal'?0.6:0.8);
      const pipeSpeed = diff==='easy'?2: (diff==='normal'?3:4);
      const canvas = document.createElement('canvas'); canvas.width=420; canvas.height=420; canvas.className='game-canvas'; 
      canvas.style.width = '100%'; canvas.style.maxWidth = `420px`; // Giữ tỷ lệ
      container.appendChild(canvas);
      
      const ctx = canvas.getContext('2d');
      let y = canvas.height / 2, vy=0, pipes=[], score=0; // Bắt đầu ở giữa
      let tick = setInterval(loop, 30);
      
      // Tạo ống đầu tiên xa hơn để tránh chết ngay lập tức
      pipes.push({x: canvas.width * 1.5, top: 150, gap: 100, scored: false});

      function loop(){
        vy += gravity; y += vy;
        
        // Sinh ống
        if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width * 0.5) {
            pipes.push({x: canvas.width, top: 60 + Math.random()*180, gap: 100, scored: false});
        }
        
        pipes.forEach(p=> p.x -= pipeSpeed); 
        pipes = pipes.filter(p => p.x > -80);
        
        const birdRect = {x:50, y, w:30, h:22};
        
        for(let p of pipes){
          // Kiểm tra va chạm
          if(birdRect.x < p.x + 60 && birdRect.x + birdRect.w > p.x) {
              if(birdRect.y < p.top || birdRect.y + birdRect.h > p.top + p.gap) { 
                  gameOver(); return; 
              }
          }
          // Ghi điểm
          if(!p.scored && p.x + 60 < 50){ 
              score++; p.scored=true; 
          }
        }
        // Kiểm tra chạm đất/trần
        if(y > canvas.height - 22 || y < 0) { gameOver(); return; }
        draw();
      }
      
      function draw(){
        ctx.fillStyle='#72c3ff'; ctx.fillRect(0,0,canvas.width,canvas.height);
        // Draw Ground
        ctx.fillStyle='#0a0'; ctx.fillRect(0, canvas.height - 10, canvas.width, 10);
        
        pipes.forEach(p=>{ ctx.fillStyle='#0b3'; ctx.fillRect(p.x,0,60,p.top); ctx.fillRect(p.x,p.top + p.gap,60,canvas.height - (p.top + p.gap)); });
        ctx.fillStyle='#ffea7f'; ctx.fillRect(50, y, 30, 22);
        ctx.fillStyle='#000'; ctx.fillText('Score: '+score, 10, 20);
      }
      function flap(){ vy = -8; }
      function gameOver() { clearInterval(tick); showAlert('Game Over! Score: '+score, () => { pushScore(APP.playerName, score, 'flappy'); closeGame(); }); }
      const keyHandler = (e)=>{ if(e.key===' ') flap(); };
      document.addEventListener('keydown', keyHandler);
      container.addEventListener('click', () => flap());
      window.GAME = { destroy(){ clearInterval(tick); document.removeEventListener('keydown', keyHandler); } };
    }

    /* 6) 2048 Implementation (FIXED: Added missing rotate function) */
    function init2048(container, mode){
        let grid = newGrid(), score=0;
        // Implement PvP here if needed, current is AI/single player logic
        container.innerHTML = '<div><strong>2048</strong><div class="muted small">Use arrow keys to move</div></div>';
        const board = document.createElement('div'); 
        board.className = 'board2048';
        container.appendChild(board);
        const scoreEl = document.createElement('div'); scoreEl.className='muted small'; scoreEl.textContent='Score: 0'; container.appendChild(scoreEl);
        renderGrid();
        
        function newGrid(){ const g=Array.from({length:4},()=>Array(4).fill(0)); randomTile(g); randomTile(g); return g; }
        function randomTile(g){
          const empt=[]; for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(!g[r][c]) empt.push([r,c]);
          if(empt.length===0) return; const [r,c] = empt[Math.floor(Math.random()*empt.length)]; g[r][c] = Math.random()<0.9?2:4;
        }
        function renderGrid(){
          board.innerHTML=''; grid.flat().forEach(v=>{ const el=document.createElement('div'); el.className = 'tile2048'; el.textContent = v||''; el.style.backgroundColor = `rgba(255,255,255,${Math.log2(v||1)*0.05})`; board.appendChild(el); });
          scoreEl.textContent = 'Score: '+score;
        }
        function move(dir){
          const old = JSON.stringify(grid);
          let g=grid.map(r=>r.slice()), gained=0;
          for(let i=0;i<dirSteps(dir);i++) g=rotate(g);
          for(let r=0;r<4;r++){
            let row = g[r].filter(v=>v); for(let i=0;i<row.length-1;i++) if(row[i]===row[i+1]){ row[i]*=2; gained += row[i]; row.splice(i+1,1); }
            while(row.length<4) row.push(0); g[r]=row;
          }
          for(let i=0;i<(4-dirSteps(dir)) % 4;i++) g=rotate(g);
          if(JSON.stringify(g)!==old){ randomTile(g); grid=g; score+=gained; renderGrid(); if(checkWin(grid)){ showAlert('Bạn thắng! Score: '+score, () => {pushScore(APP.playerName, score, '2048'); closeGame();}); } }
        }
        function dirSteps(dir){ if(dir==='left') return 0; if(dir==='up') return 1; if(dir==='right') return 2; if(dir==='down') return 3; }
        function rotate(m){ 
            // Hàm xoay ma trận 90 độ (cần thiết cho 2048)
            const n=Array.from({length:4},()=>Array(4).fill(0)); 
            for(let r=0;r<4;r++) for(let c=0;c<4;c++) n[r][c]=m[3-c][r]; 
            return n; 
        }
        function checkWin(g){ return g.some(r=>r.some(c=>c>=2048)); }
        const onKey = e => { if(e.key.includes('Arrow')) move(e.key.replace('Arrow','').toLowerCase()); };
        document.addEventListener('keydown', onKey);
        window.GAME = { destroy(){ document.removeEventListener('keydown', onKey); } };
    }
    
    // --- 7) Tic-Tac-Toe Implementation ---
    function initTicTacToe(container, mode) {
        const size = parseInt(getEl('tictactoeSize').value, 10);
        const boardSize = size * size;
        const WIN_CONDITION = 3; // Thắng khi 3 ô liên tiếp (đơn giản hóa)
        let board = Array(boardSize).fill(null);
        let currentPlayer = 'X';
        let gameOver = false;
        let pvpGameRef = null;
        let unsubscribe = null;
        
        const boardEl = document.createElement('div');
        // FIXED: Apply CSS directly using parameters for multi-grid support
        boardEl.style.cssText = `
            display: grid; 
            grid-template-columns: repeat(${size}, 1fr); 
            gap: ${size > 6 ? '4px' : '8px'}; 
            max-width: ${size * 50}px; 
            margin: 15px auto;
            width: 100%;
        `;
        container.appendChild(boardEl);
        
        const infoEl = document.createElement('div');
        infoEl.style.width = '100%';
        infoEl.style.marginTop = '15px';
        infoEl.style.textAlign = 'center';
        container.appendChild(infoEl);
        
        let pvpState = {}; 


        function checkWinner() {
            // Kiểm tra chiến thắng (3 ô liên tiếp, hoặc 4 ô nếu game lớn hơn)
            const winLength = WIN_CONDITION; // Giữ 3 ô liên tiếp cho tất cả các kích thước
            
            // 1. Kiểm tra hàng ngang (rows)
            for (let r = 0; r < size; r++) {
                for (let c = 0; c <= size - winLength; c++) {
                    const mark = board[r * size + c];
                    if (mark === null) continue;
                    let count = 0;
                    for (let k = 0; k < winLength; k++) {
                        if (board[r * size + c + k] === mark) count++;
                    }
                    if (count === winLength) return mark;
                }
            }
            
            // 2. Kiểm tra hàng dọc (columns)
            for (let c = 0; c < size; c++) {
                for (let r = 0; r <= size - winLength; r++) {
                    const mark = board[r * size + c];
                    if (mark === null) continue;
                    let count = 0;
                    for (let k = 0; k < winLength; k++) {
                        if (board[(r + k) * size + c] === mark) count++;
                    }
                    if (count === winLength) return mark;
                }
            }

            // 3. Kiểm tra đường chéo chính (\)
            for (let r = 0; r <= size - winLength; r++) {
                for (let c = 0; c <= size - winLength; c++) {
                    const mark = board[r * size + c];
                    if (mark === null) continue;
                    let count = 0;
                    for (let k = 0; k < winLength; k++) {
                        if (board[(r + k) * size + c + k] === mark) count++;
                    }
                    if (count === winLength) return mark;
                }
            }
            
            // 4. Kiểm tra đường chéo phụ (/)
            for (let r = 0; r <= size - winLength; r++) {
                for (let c = winLength - 1; c < size; c++) {
                    const mark = board[r * size + c];
                    if (mark === null) continue;
                    let count = 0;
                    for (let k = 0; k < winLength; k++) {
                        if (board[(r + k) * size + c - k] === mark) count++;
                    }
                    if (count === winLength) return mark;
                }
            }

            // Hòa
            return board.includes(null) ? null : 'Tie';
        }
        
        function checkEndState(isPvp) {
            const winner = checkWinner();
            if (winner) {
                gameOver = true;
                const message = winner === 'Tie' ? 'Hòa!' : `"${winner}" thắng!`;
                infoEl.textContent = message;
                
                if (!isPvp) {
                    const score = winner === 'X' ? 100 : (winner === 'Tie' ? 10 : 0);
                    showAlert(message, () => {
                        pushScore(APP.playerName, score, 'tictactoe');
                        closeGame();
                    });
                } else if (pvpGameRef) {
                    // Cập nhật trạng thái chiến thắng lên cloud (PvP)
                    updateDoc(pvpGameRef, { winner: winner, isOver: true });
                }
                return true;
            }
            return false;
        }

        function handleClick(index) {
            // Check nếu không phải lượt mình, hoặc game over, hoặc ô đã có người đánh
            if (gameOver || board[index]) return;
            
            if (mode === 'ai') {
                if (currentPlayer !== 'X') return; // Chỉ cho người chơi (X) click
                board[index] = 'X';
                currentPlayer = 'O';
                render();
                if(!checkEndState(false)) setTimeout(aiMove, 500);
            } else if (mode === 'pvp' && pvpGameRef && auth.currentUser.uid === pvpState.turn) {
                 // Logic PvP
                 const playerMark = auth.currentUser.uid === pvpState.player1Id ? 'X' : 'O';
                 board[index] = playerMark;
                 render(); // Cập nhật local ngay lập tức
                 
                 // Đẩy lên Cloud
                 updateDoc(pvpGameRef, { 
                    board: JSON.stringify(board), 
                    turn: auth.currentUser.uid === pvpState.player1Id ? pvpState.player2Id : pvpState.player1Id 
                 });
                 checkEndState(true);
            }
        }
        
        function aiMove() {
            let emptyCells = board.map((v, i) => v === null ? i : null).filter(v => v !== null);
            if (emptyCells.length === 0) return;
            let move = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            board[move] = 'O';
            currentPlayer = 'X';
            render();
            checkEndState(false);
        }

        function render(state = {}) {
            pvpState = state; // Cập nhật trạng thái PvP

            boardEl.innerHTML = '';
            
            let isMyTurn = true;
            if (mode === 'pvp') {
                const isTurn = auth.currentUser.uid === state.turn;
                isMyTurn = isTurn;
                
                // Cập nhật trạng thái phòng chơi
                infoEl.textContent = state.winner ? `Game Over. ${state.winner} thắng!` : 
                                      state.player2Id ? (isTurn ? 'Lượt của BẠN' : 'Đang chờ đối thủ...') : 
                                      'Đang chờ người chơi thứ 2...';
                
                if (state.board) board = JSON.parse(state.board);
            } else {
                infoEl.textContent = 'Lượt của bạn (X)';
            }
            
            board.forEach((cell, index) => {
                const cellEl = document.createElement('div');
                // FIXED: Apply dynamic style for TTT cell based on size
                cellEl.style.cssText = `
                    width: 100%; 
                    aspect-ratio: 1 / 1; 
                    background-color: rgba(0,0,0,0.2); 
                    border-radius: ${size > 3 ? '4px' : '10px'}; 
                    display: flex; 
                    align-items: center; 
                    justify-content: center; 
                    font-size: ${size >= 8 ? '1.5em' : '2.5em'};
                    font-weight: bold; 
                    cursor: pointer; 
                    transition: background-color 0.2s;
                    color: ${cell === 'X' ? 'var(--accent1)' : 'var(--accent2)'};
                `;
                cellEl.textContent = cell;
                
                if (mode === 'pvp') {
                     // Nếu PvP: Chỉ click được khi đến lượt mình và ô trống
                    cellEl.onclick = () => { if (isMyTurn && cell === null && !state.isOver) handleClick(index); };
                    cellEl.style.cursor = (isMyTurn && cell === null && !state.isOver) ? 'pointer' : 'default';
                } else {
                    // Nếu AI: Chỉ click khi là X
                    cellEl.onclick = () => handleClick(index);
                }
                
                boardEl.appendChild(cellEl);
            });
        }
        
        async function setupPvp() {
            infoEl.textContent = 'Đang tìm phòng chơi...';
            const gameCollection = collection(db, "tictactoe_lobbies");
            
            // --- Logic Tự động Ghép phòng ---
            // Thêm lọc theo kích thước bàn cờ
            const q = query(gameCollection, where("player2Id", "==", null), where("size", "==", size), limit(1));
            const availableLobbies = await getDocs(q);
            
            let lobbyId;
            
            if (!availableLobbies.empty) {
                // TÌM THẤY phòng đang chờ
                const lobbyDoc = availableLobbies.docs[0];
                lobbyId = lobbyDoc.id;
                
                if (lobbyDoc.data().player1Id === auth.currentUser.uid) {
                    // Nếu chính mình tạo phòng này, chờ người khác vào
                    pvpGameRef = doc(gameCollection, lobbyId);
                    infoEl.innerHTML = `Đã tạo phòng. ${size}x${size}. Bạn là X. Đang chờ đối thủ...`;
                } else {
                    // Tham gia phòng
                    pvpGameRef = doc(gameCollection, lobbyId);
                    
                    APP.player1Id = lobbyDoc.data().player1Id; 
                    APP.player2Id = auth.currentUser.uid;
                    
                    await updateDoc(pvpGameRef, { player2Id: APP.player2Id, player2Name: APP.playerName });
                    infoEl.textContent = `Tham gia thành công. ${size}x${size}. Bạn là O.`;
                }
                
            } else {
                // KHÔNG TÌM THẤY, TẠO phòng mới
                lobbyId = Utils.generateGameId();
                pvpGameRef = doc(gameCollection, lobbyId);
                
                APP.player1Id = auth.currentUser.uid;
                APP.player2Id = null;

                const initialBoard = Array(boardSize).fill(null);
                await setDoc(pvpGameRef, {
                    gameId: lobbyId,
                    size: size, // LƯU KÍCH THƯỚC
                    player1Id: APP.player1Id,
                    player1Name: APP.playerName,
                    player2Id: null,
                    player2Name: null,
                    board: JSON.stringify(initialBoard),
                    turn: APP.player1Id, // X luôn đi trước
                    isOver: false,
                    createdAt: Date.now() 
                });
                infoEl.innerHTML = `Đã tạo phòng. ${size}x${size}. Bạn là X. Đang chờ đối thủ...`;
            }
            
            // Lắng nghe trạng thái phòng chơi
            unsubscribe = onSnapshot(pvpGameRef, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const state = docSnapshot.data();
                    render(state);
                    if (state.isOver) {
                        unsubscribe();
                        showAlert(`Game Over! ${state.winner} thắng!`, () => closeGame());
                    }
                } else {
                    showAlert('Phòng đã bị đóng bởi người chơi khác.', () => closeGame());
                }
            }, (error) => {
                 console.error("Firebase PvP snapshot error:", error);
                 showAlert('Lỗi kết nối PvP. (Kiểm tra Rules)', () => closeGame());
            });
        }

        if (mode === 'pvp') {
            setupPvp();
            window.GAME = { 
                destroy: () => { 
                    if(unsubscribe) unsubscribe(); 
                    if(pvpGameRef && APP.player1Id === auth.currentUser.uid && !gameOver && !pvpState.player2Id) {
                        // Vô hiệu hóa việc xóa phòng để tránh lỗi permission
                        // deleteDoc(pvpGameRef).catch(e => console.error("Lỗi xóa phòng trống:", e));
                    }
                } 
            };
        } else {
            render();
            window.GAME = { destroy: () => {} };
        }
    }
    
    // --- 8) Battleship (Hải Chiến) Implementation (PvP & AI) ---
    function initBattleship(container, mode) {
        
        let pvpGameRef = null;
        let unsubscribe = null;
        let myShipBoard = Utils.placeShipsRandomly();
        let myHitBoard = Array(10).fill(0).map(() => Array(10).fill(null)); 
        let opponentHitBoard = Array(10).fill(0).map(() => Array(10).fill(null)); 
        let myPlayerId = auth.currentUser.uid; 
        let opponentPlayerId = null; 
        let aiShipBoard = null;
        let aiHits = Array(10).fill(0).map(() => Array(10).fill(null));
        let isAiTurn = false;
        // FIX: Khai báo biến currentPlayer ở đầu hàm
        let currentPlayer;
        
        const root = document.createElement('div');
        root.innerHTML = `
            <div style="text-align:center; margin-bottom: 15px;">
                <h4 id="bsStatus">Đang tìm phòng...</h4>
                <div class="muted small" id="bsTurnInfo"></div>
            </div>
            <div style="display:flex; justify-content: space-around; flex-wrap: wrap; gap: 20px;">
                <div>
                    <div style="font-weight: bold; color: var(--accent2);">Bàn chơi của bạn (Ship)</div>
                    <div id="myBoard" class="battleship-grid"></div>
                </div>
                <div>
                    <div style="font-weight: bold; color: var(--accent1);">Bàn chơi đối thủ (Attack)</div>
                    <div id="opponentBoard" class="battleship-grid"></div>
                </div>
            </div>
            <div id="shipsLeft" style="margin-top: 15px; text-align: center; color: var(--muted);"></div>
        `;
        container.appendChild(root);

        const myBoardEl = getEl('myBoard');
        const opponentBoardEl = getEl('opponentBoard');
        const bsStatus = getEl('bsStatus');
        const bsTurnInfo = getEl('bsTurnInfo');
        const shipsLeftEl = getEl('shipsLeft');
        
        const gridSize = 10;

        function boardToFirestore(board2D, hitBoard2D) {
            const flatShip = board2D.map(row => row.join(',')).join(';');
            const flatHit = hitBoard2D.map(row => row.map(v => v || 'null').join(',')).join(';');
            return { flatShip, flatHit };
        }
        
        function parseBoardFromFirestore(flatBoard) {
             return flatBoard.split(';').map(row => row.split(',').map(v => v === 'null' ? null : v));
        }
        function parseShipBoardFromFirestore(flatBoard) {
             return flatBoard.split(';').map(row => row.split(',').map(v => v === 'true'));
        }

        function renderBoards(state = {}) {
            let isReady = true;
            let isMyTurn = true;
            let currentOpponentHitBoard = null;
            let currentMyHitBoard = null;
            let currentMyShipBoard = myShipBoard;
            
            if (mode === 'pvp') {
                isReady = state.player1ShipBoard && state.player2ShipBoard;
                isMyTurn = state.turn === myPlayerId;
                const isHost = myPlayerId === state.player1Id;
                opponentPlayerId = myPlayerId === state.player1Id ? state.player2Id : state.player1Id;

                // Lấy board từ Cloud
                currentMyHitBoard = isHost ? parseBoardFromFirestore(state.hitsP2) : parseBoardFromFirestore(state.hitsP1);
                currentOpponentHitBoard = isHost ? parseBoardFromFirestore(state.hitsP1) : parseBoardFromFirestore(state.hitsP2);
                currentMyShipBoard = isHost ? parseShipBoardFromFirestore(state.player1ShipBoard) : parseShipBoardFromFirestore(state.player2ShipBoard);
                
                if (isReady && !state.isOver) {
                    bsStatus.textContent = isMyTurn ? 'LƯỢT CỦA BẠN: Tấn công!' : 'Đang chờ đối thủ...';
                    bsTurnInfo.textContent = `Phòng ID: ${state.gameId} | Bạn: ${APP.playerName} (${isHost ? 'P1' : 'P2'})`;
                } else if (state.isOver) {
                     bsStatus.textContent = `GAME OVER! ${state.winnerName} thắng!`;
                     bsTurnInfo.textContent = `Người thắng: ${state.winnerName}. ID phòng: ${state.gameId}`;
                } else {
                     bsStatus.textContent = 'Đang chờ người chơi 2...';
                }

            } else { // AI MODE
                isAiTurn = currentPlayer !== myPlayerId;
                isMyTurn = !isAiTurn;
                currentMyHitBoard = myHitBoard;
                currentOpponentHitBoard = opponentHitBoard;
                bsStatus.textContent = isMyTurn ? 'LƯỢT CỦA BẠN: Tấn công AI!' : 'Đang chờ AI...';
                bsTurnInfo.textContent = 'Chế độ Chơi AI (AI bắn ngẫu nhiên)';
            }
            
            // Render My Board
            myBoardEl.innerHTML = '';
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'b-cell';
                    if (currentMyShipBoard[r][c]) {
                        cell.classList.add('ship');
                        if (currentMyHitBoard[r][c] === 'hit') {
                            cell.classList.add('hit');
                            cell.textContent = '🔥';
                        } else {
                            cell.textContent = '🛥️';
                        }
                    } else if (currentMyHitBoard[r][c] === 'miss') {
                        cell.classList.add('miss');
                        cell.textContent = '💧';
                    }
                    myBoardEl.appendChild(cell);
                }
            }
            
            // Render Opponent Board (Attack)
            opponentBoardEl.innerHTML = '';
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'b-cell';
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    
                    if (currentOpponentHitBoard[r][c] === 'hit') {
                        cell.classList.add('hit');
                        cell.textContent = '🔥';
                    } else if (currentOpponentHitBoard[r][c] === 'miss') {
                        cell.classList.add('miss');
                        cell.textContent = '💧';
                    } 
                    
                    let canAttack = mode === 'pvp' ? (isReady && isMyTurn && !state.isOver) : isMyTurn;
                    
                    if (canAttack && !currentOpponentHitBoard[r][c]) {
                        cell.style.cursor = 'pointer';
                        cell.onclick = handleAttack;
                    }
                    opponentBoardEl.appendChild(cell);
                }
            }
            
            shipsLeftEl.textContent = `Thuyền của bạn còn: ${Utils.countShipsLeft(currentMyShipBoard, currentMyHitBoard)}/17`;
            
            if (state.isOver && mode === 'pvp') {
                opponentBoardEl.querySelectorAll('.b-cell').forEach(c => c.onclick = null);
            }
        }
        
        // Logic AI bắn (Chế độ chơi đơn)
        function aiShoot() {
            if (!isAiTurn) return;
            
            // Tìm ô chưa bị bắn trên bàn chơi của người chơi (myHitBoard)
            let unhitCells = [];
            for(let r=0; r<gridSize; r++) {
                for(let c=0; c<gridSize; c++) {
                    if (myHitBoard[r][c] === null) {
                        unhitCells.push({r, c});
                    }
                }
            }
            
            if (unhitCells.length > 0) {
                const target = unhitCells[Math.floor(Math.random() * unhitCells.length)];
                
                const isHit = myShipBoard[target.r][target.c];
                const hitStatus = isHit ? 'hit' : 'miss';
                
                myHitBoard[target.r][target.c] = hitStatus;
                
                if (isHit) {
                    bsTurnInfo.textContent = 'AI đã bắn TRÚNG!';
                } else {
                    bsTurnInfo.textContent = 'AI đã bắn TRƯỢT.';
                }
                
                currentPlayer = myPlayerId; // Chuyển lượt lại cho người chơi
                renderBoards();
                checkGameOver(false);
            }
        }

        async function handleAttack(e) {
            const r = parseInt(e.target.dataset.r);
            const c = parseInt(e.target.dataset.c);
            
            if (opponentHitBoard[r][c]) return;

            // Tạm thời disable click
            opponentBoardEl.querySelectorAll('.b-cell').forEach(c => c.onclick = null);

            if (mode === 'pvp') {
                // Logic PvP (Cloud)
                if (!pvpGameRef || !auth.currentUser) return;
                await updateDoc(pvpGameRef, { 
                    lastAttack: JSON.stringify({ r, c, attackerId: myPlayerId }),
                    turn: opponentPlayerId, // Chuyển lượt cho đối thủ
                }); 
                
            } else { 
                // Logic AI (Single Player)
                const isHit = aiShipBoard[r][c];
                const hitStatus = isHit ? 'hit' : 'miss';
                
                opponentHitBoard[r][c] = hitStatus;
                
                if (isHit) {
                    bsTurnInfo.textContent = 'Bắn TRÚNG! Tiếp tục lượt...';
                } else {
                    bsTurnInfo.textContent = 'Bắn TRƯỢT. Chuyển lượt cho AI...';
                    currentPlayer = 'AI';
                    renderBoards();
                    
                    // Kích hoạt AI bắn
                    setTimeout(aiShoot, 1000);
                }
                
                renderBoards();
                checkGameOver(false);
            }
        }
        
        function checkGameOver(isPvp, winnerId = null, winnerName = null) {
            let myShipsLeft = Utils.countShipsLeft(myShipBoard, myHitBoard);
            let opponentShipsLeft = mode === 'pvp' 
                ? (isPvp ? (myPlayerId === pvpState.player1Id ? pvpState.player2ShipsLeft : pvpState.player1ShipsLeft) : 17) // PvP sẽ kiểm tra từ state (không dùng local)
                : Utils.countShipsLeft(aiShipBoard, opponentHitBoard); // AI dùng board local
                
            if (myShipsLeft <= 0 || opponentShipsLeft <= 0) {
                const winner = myShipsLeft > 0 ? APP.playerName : (mode === 'pvp' ? winnerName : 'AI');
                const score = myShipsLeft > 0 ? 1000 + opponentShipsLeft * 10 : 0;
                
                if (isPvp) {
                    // PvP đã được xử lý qua onSnapshot và updateDoc
                    return;
                }
                
                showAlert(`Game Over! ${winner} thắng! Điểm: ${score}`, () => {
                    pushScore(APP.playerName, score, 'battleship');
                    closeGame();
                });
                
                if (window.GAME.destroy) window.GAME.destroy();
            }
        }
        
        async function setupPvp() {
            // Khởi tạo trạng thái cho PvP (đã giữ nguyên logic tự động ghép phòng)
            bsStatus.textContent = 'Đang tìm phòng chơi...';
            // ... (Logic PvP tự động ghép phòng - giữ nguyên như phiên bản trước) ...
            
            const gameCollection = collection(db, "battleship_lobbies");
            
            const q = query(gameCollection, where("player2Id", "==", null), limit(1));
            const availableLobbies = await getDocs(q);
            
            let lobbyId;
            myPlayerId = auth.currentUser.uid;
            opponentPlayerId = null;

            if (!availableLobbies.empty) {
                const lobbyDoc = availableLobbies.docs[0];
                lobbyId = lobbyDoc.id;
                
                if (lobbyDoc.data().player1Id === myPlayerId) {
                    pvpGameRef = doc(gameCollection, lobbyId);
                    bsStatus.innerHTML = `Đã tạo phòng. Bạn là P1. Đang chờ đối thủ...`;
                } else {
                    pvpGameRef = doc(gameCollection, lobbyId);
                    opponentPlayerId = lobbyDoc.data().player1Id;
                    
                    const { flatShip: flatShipBoard, flatHit: flatHitBoard } = boardToFirestore(myShipBoard, myHitBoard);
                    
                    await updateDoc(pvpGameRef, { 
                        player2Id: myPlayerId, 
                        player2Name: APP.playerName,
                        player2ShipBoard: flatShipBoard,
                        hitsP2: flatHitBoard,
                    });
                    bsStatus.innerHTML = `Tham gia thành công. Bạn là P2. Đang chờ P1 đi trước...`;
                }
                
            } else {
                lobbyId = Utils.generateGameId();
                pvpGameRef = doc(gameCollection, lobbyId);
                
                const { flatShip: flatShipBoard, flatHit: flatHitBoard } = boardToFirestore(myShipBoard, myHitBoard);

                await setDoc(pvpGameRef, {
                    gameId: lobbyId,
                    player1Id: myPlayerId,
                    player1Name: APP.playerName,
                    player2Id: null, 
                    player2Name: null,
                    player1ShipBoard: flatShipBoard,
                    player2ShipBoard: null, 
                    hitsP1: flatHitBoard,
                    hitsP2: flatHitBoard,
                    turn: myPlayerId,
                    lastAttack: null,
                    isOver: false,
                    winnerId: null,
                    winnerName: null,
                    createdAt: Date.now()
                });
                bsStatus.innerHTML = `Đã tạo phòng. Bạn là P1. Đang chờ đối thủ...`;
            }
            
            unsubscribe = onSnapshot(pvpGameRef, async (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const state = docSnapshot.data();
                    opponentPlayerId = myPlayerId === state.player1Id ? state.player2Id : state.player1Id;

                    if (state.lastAttack) {
                        const attackData = JSON.parse(state.lastAttack);
                        
                        if (attackData.attackerId === opponentPlayerId && state.turn === myPlayerId) {
                             const { r, c } = attackData;
                            
                            const myShipBoardFlat = myPlayerId === state.player1Id ? state.player1ShipBoard : state.player2ShipBoard;
                            const myShipBoard2D = parseShipBoardFromFirestore(myShipBoardFlat);
                            
                            const isHit = myShipBoard2D[r][c];
                            const hitStatus = isHit ? 'hit' : 'miss';
                            
                            const myHitsField = myPlayerId === state.player1Id ? 'hitsP2' : 'hitsP1'; 
                            
                            let currentMyHits = parseBoardFromFirestore(state[myHitsField]);
                            currentMyHits[r][c] = hitStatus;
                            
                            const { flatHit: newMyHitsFlat } = boardToFirestore(myShipBoard, currentMyHits);
                            
                            const shipsRemaining = Utils.countShipsLeft(myShipBoard2D, currentMyHits);
                            let gameOverUpdate = {};
                            
                            if (shipsRemaining <= 0) {
                                gameOverUpdate = {
                                    isOver: true,
                                    winnerId: opponentPlayerId,
                                    winnerName: myPlayerId === state.player1Id ? state.player2Name : state.player1Name,
                                };
                                showAlert(`Thuyền của bạn đã bị tiêu diệt hết! ${gameOverUpdate.winnerName} thắng!`, () => {
                                    pushScore(APP.playerName, 0, 'battleship');
                                    closeGame();
                                });
                            }

                            await updateDoc(pvpGameRef, {
                                [myHitsField]: newMyHitsFlat,
                                lastAttack: null, 
                                ...gameOverUpdate
                            });
                        }
                    }
                    
                    renderBoards(state);
                } else {
                    showAlert('Phòng không tồn tại.', () => closeGame());
                }
            }, (error) => {
                 console.error("Firebase Battleship snapshot error:", error);
                 showAlert('Lỗi kết nối PvP. (Kiểm tra Rules)', () => closeGame());
            });
        }
        
        if (mode === 'pvp') {
            setupPvp();
        } else {
            // AI Mode Setup
            aiShipBoard = Utils.placeShipsRandomly(); // AI có bàn chơi riêng
            currentPlayer = myPlayerId;
            renderBoards();
        }

        window.GAME = { 
            destroy: () => { 
                if(unsubscribe) unsubscribe(); 
                // Logic dọn dẹp phòng trống (chỉ người tạo phòng mới làm)
                if(mode === 'pvp' && pvpGameRef && myPlayerId === auth.currentUser.uid && !opponentPlayerId) {
                    // Vô hiệu hóa việc xóa phòng để tránh lỗi permission
                    // deleteDoc(pvpGameRef).catch(e => console.error("Lỗi xóa phòng trống:", e));
                }
            } 
        };
    }


    // --- Initial Load ---
    async function init(){
      if (firebaseActive) {
          try {
            await signInAnonymously(auth); 
            console.log("Signed in anonymously to Firebase.");
            leaderboardStatus.textContent = 'Online (Đã đăng nhập)';
          } catch(e) {
            console.error("Anonymous sign in failed. Check Firebase settings.", e);
            firebaseActive = false; 
            leaderboardStatus.textContent = 'Lỗi Auth Firebase.';
          }
      }
      
      // KHÔI PHỤC: Tải tên người chơi từ localStorage khi khởi động
      const p = localStorage.getItem('sg_hub_player_name'); 
      if(p){ 
        playerInput.value = p; 
        APP.playerName = p; 
        playerDisplay.textContent = p; 
        modalPlayer.textContent = p; 
      }
      
      applyTheme();
      refreshLeaderboardUI(); 
      setupEventListeners();
    }
    
    init();
    
    window.closeGame = closeGame; 

  })();
</script>
<script src="/_vercel/insights/script.js"></script>
<script src="/_vercel/speed-insights/script.js"></script>
</body>
</html>

